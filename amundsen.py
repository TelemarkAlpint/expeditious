#!/usr/bin/env python

""" Amundsen converts the .flac file generated by Monsen and create web friendly
mp3 and ogg versions of it, and transfer it to a directory of your choice.

Requires SoX and lame to do the encoding (both must be available on the PATH).

Encoding settings are configurable in the config.yaml file.

The filename output can be copy-pasted into slingsbys approve song form.
"""

from logging import getLogger
from mutagen import File
from shutil import copy2
from os import path
import logging.config
import subprocess
import argparse
import yaml
import os

config = None
logger = getLogger('expeditious.amundsen')

def init():
    _setup_logging()
    _load_config()

def _setup_logging():
    with open('log_conf.yaml') as log_conf_file:
        log_config = yaml.load(log_conf_file)
    logging.config.dictConfig(log_config)

def _load_config():
    global config
    with open('config.yaml') as config_file:
        config = yaml.load(config_file)

def run():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('input', help='The source file to be converted.')
    args = parser.parse_args()
    src_file = args.input
    wav_file = to_wav(src_file)
    load_metadata_to_config(src_file)
    converted_files = convert_file(wav_file)
    os.remove(wav_file)
    filename = os.path.splitext(os.sep.join(converted_files[0].split(os.sep)[-2:]))[0]
    logger.info('\n\nFilename (without extension): \n%s', filename)
    set_clipboard_if_possible(filename)

def load_metadata_to_config(src_file):
    artist = get_artist(src_file)
    title = get_title(src_file)
    metadata = {'title': title, 'artist': artist}
    config['metadata'] = metadata

def copy(src_files, dest):
    for src_file in src_files:
        copy2(src_file, dest)

def to_wav(src_file):
    new_filename = path.splitext(src_file)[0] + '.wav'
    command = ['sox', src_file, new_filename]
    subprocess.check_call(command)
    return new_filename

def convert_file(src):
    formats = config['formats']
    metadata = config['metadata']
    artist = metadata['artist']
    filename = path.split(src)[1]
    basename = path.splitext(filename)[0]
    target_folder = path.join(config['music_src_dir'], artist)
    if not os.path.exists(target_folder):
        os.makedirs(target_folder)
    converted = []
    for format in formats.values():
        new_filename = '%s%s' % (basename, format['extension'])
        target = path.join(target_folder, new_filename)
        command = [format['application']] + format.get('arguments', []) + [src, target]
        logger.info("New file: %s", new_filename)
        subprocess.check_call(command)
        converted.append(target)
    return converted

def get_artist(song):
    alts = ['artist', 'Artist', 'ARTIST', 'TPE1']
    return _get_property(song, alts)

def get_title(song):
    alts = ['Title', 'title', 'TITLE', 'TIT2']
    return _get_property(song, alts)

def _get_property(song, alts):
    audio = File(song)
    for alt in alts:
        try:
            return audio[alt][0]
        except ImportError:
            pass
    return None

def set_clipboard_if_possible(string):
    try:
        from Tkinter import Tk
    except ImportError:
        return
    r = Tk()
    r.withdraw()
    r.clipboard_clear()
    r.clipboard_append(string)
    r.destroy()
    print 'Filename copied to your clipboard.'

if __name__ == '__main__':
    init()
    run()